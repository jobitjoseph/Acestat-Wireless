/******************************************************************************
Copyright (c) 2017-2019 Analog Devices, Inc. All Rights Reserved.

This software is proprietary to Analog Devices, Inc. and its licensors.
By using this software you agree to the terms of the associated
Analog Devices Software License Agreement.

*****************************************************************************/

#include "stdint.h"
#include "string.h"
#include "stdio.h"

#define LINEBUFF_SIZE 128
#define CMDTABLE_SIZE 8

uint32_t help(uint32_t para1, uint32_t para2);
uint32_t say_hello(uint32_t para1, uint32_t para2);
uint32_t rst_eda_base(uint32_t para1, uint32_t para2);
uint32_t set_eda_base(uint32_t para1, uint32_t para2);
uint32_t get_average_imp(uint32_t para1, uint32_t para2);
uint32_t eda_start(uint32_t para1, uint32_t para2);
uint32_t eda_stop(uint32_t para1, uint32_t para2);

struct __uartcmd_table
{
  void *pObj;
  const char *cmd_name;
  const char *pDesc;
}uart_cmd_table[CMDTABLE_SIZE]=
{
  {(void*)help, "help", "print supported commands"},
  {(void*)help, "?", "print supported commands"},
  {(void*)say_hello, "hello", "print parameteres and say hello"},
  {(void*)eda_start, "edastart", "Start EDA measurment"},
  {(void*)eda_stop, "edastop", "Stop EDA measurment immediately"},
  {(void*)rst_eda_base, "rstbase", "Reset EDA baseline impedance"},
  {(void*)set_eda_base, "setbase", "Set EDA impedance baseline with current averaged impedance result"},
  {(void*)get_average_imp, "getavr", "get average impedance of all result"},
};


uint32_t help(uint32_t para1, uint32_t para2)
{
  int i = 0;
  printf("*****help menu*****\nbelow are supported commands:\n");
  for(;i<CMDTABLE_SIZE;i++)
  {
    if(uart_cmd_table[i].pObj)
      printf("%-8s --\t%s\n", uart_cmd_table[i].cmd_name, uart_cmd_table[i].pDesc);
  }
  printf("***table end***\n");
  return 0x87654321;
}

uint32_t say_hello(uint32_t para1, uint32_t para2)
{
  printf("para1:0x%08x, para2:0x%08x\n", para1, para2);
  printf("Hello\n");
  return 0x12345678;
}

char line_buffer[LINEBUFF_SIZE];
uint32_t line_buffer_index = 0;
uint32_t token_count = 0;
void *pObjFound = 0;
uint32_t parameter1, parameter2;

void UARTCmd_RemoveSpaces(void)
{
  int i = 0;
  token_count = 0;
  char flag_found_token = 0;
  while(i<line_buffer_index)
  {
    if(line_buffer[i] == ' ') line_buffer[i] = '\0';
    else break;
    i++;
  }
  if(i == line_buffer_index) return;  /* All spaces... */
  while(i<line_buffer_index)
  {
    if(line_buffer[i] == ' ')
    {
      line_buffer[i] = '\0';
      flag_found_token = 0;
    }
    else
    { 
      if(flag_found_token == 0)
        token_count ++;
      flag_found_token = 1;
    }
    i++;
  }
}

void UARTCmd_MatchCommand(void)
{
  char *pcmd;
  int i = 0;
  pObjFound = 0;
  while(i<line_buffer_index)
  {
    if(line_buffer[i] != '\0')
    {
      pcmd = &line_buffer[i];
      break;
    }
    i++;
  }
  for(i=0;i<CMDTABLE_SIZE;i++)
  {
    if(strcmp(uart_cmd_table[i].cmd_name, pcmd) == 0)
    {
      /* Found you! */
      pObjFound = uart_cmd_table[i].pObj;
      break;
    }
  }
}

/* calculate m^n */
static uint32_t power_int(unsigned int m,unsigned int n)
{
	unsigned int res=1;	 
	while(n--)
		res*=m;    
	return res;
}

/* Translate string 'p' to number, store results in 'Res', return error code */
static uint32_t Str2Num(char *p, uint32_t *Res)
{
	unsigned int Temp;
	unsigned int index=0;			  
	unsigned int base=10;
  char *pstart = p;
	*Res=0;
  /*  */
	while(1)
	{ /* Convert ABCD to abcd*/
		if((*p>='A'&&*p<='F')||(*p=='X'))
			*p=*p+0x20;
		else if(*p=='\0')break;
		p++;
	}
	p=pstart;
	while(1)
	{
		if((*p<='9'&&*p>='0')||(*p<='f'&&*p>='a')||(*p=='x'&&index==1))
		{
			if(*p>='a')base=16;	
			index++;					
		}else if(*p=='\0')break;	
		else return 1;				
		p++; 
	} 
	p=pstart;			    
	if(base==16)		
	{
		if(index<3)return 2;		
		if(*p=='0' && (*(p+1)=='x'))
		{
			p+=2;	
			index-=2;
		}else return 3;
	}else if(index==0)return 4;
	while(1)
	{
		if(index)index--;
		if(*p<='9'&&*p>='0')Temp=*p-'0';	
		else Temp=*p-'a'+10;				 
		*Res+=Temp*power_int(base,index);		   
		p++;
		if(*p=='\0')break;
	}
	return 0;
}

void UARTCmd_TranslateParas(void)
{
  char *p = line_buffer;
  parameter1 = 0;
  parameter2 = 0;
  while(*p == '\0') p++;    /* goto command */
  while(*p != '\0') p++;    /* skip command. */
  while(*p == '\0') p++;    /* goto first parameter */
  if(Str2Num(p, &parameter1) != 0) return;
  if(token_count == 2) return;           /* Only one parameter */
  while(*p != '\0') p++;    /* skip first command. */
  while(*p == '\0') p++;    /* goto second parameter */
  Str2Num(p, &parameter2);
}

void UARTCmd_Process(char c)
{
  if(line_buffer_index >= LINEBUFF_SIZE-1)
    line_buffer_index = 0;  /* Error: buffer overflow */
  if( (c == '\r') || (c == '\n'))
  {
    uint32_t res;
    line_buffer[line_buffer_index] = '\0';
    /* Start to process command */
    if(line_buffer_index == 0) 
    {
      line_buffer_index = 0; /* Reset buffer */
      return;  /* No command inputs, return */
    }
    /* Step1, remove space */
    UARTCmd_RemoveSpaces();
    if(token_count == 0)
    {
      line_buffer_index = 0; /* Reset buffer */
      return; /* No valid input */
    }
    /* Step2, match commands */
    UARTCmd_MatchCommand();
    if(pObjFound == 0)
    {
      line_buffer_index = 0; /* Reset buffer */
      return;   /* Command not support */
    }
    if(token_count > 1)           /* There is parameters */
    {
      UARTCmd_TranslateParas();
    }
    /* Step3, call function */
    res = ((uint32_t (*)(uint32_t, uint32_t))(pObjFound))(parameter1, parameter2);
    printf("res:0x%08x\n", res);
    line_buffer_index = 0;  /* Reset buffer */
  }
  else
  {
    line_buffer[line_buffer_index++] = c;
  }
}
